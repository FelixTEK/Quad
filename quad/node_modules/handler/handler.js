const HandlerCommand = require("./handlercommand");
const SimpleHandlerCommand = require("./simplehandlercommand");
const HandlerCommandParent = require("./handlercommandparent.js");
const matchArguments = require("./matcharguments");
const commandRegistration = require("./commandregistration");
const config = require("config");
const i18n = require("i18n");
const MiddlewareLoader = require("../../middlewareloader");
const EventEmitter = require("events");
const log = require("log");

const commandRatelimit = config.get("bot.ratelimit.commands");
const t = i18n.t;

class Handler extends EventEmitter {
	#commands;
    #bot;
    #pendingListeners;
    #mw;
    
    constructor() {
        super();
        
        this.#commands = {};
        this.#pendingListeners = [];
        this.#mw = new MiddlewareLoader();
        

        process.on("uncaughtException", err => {
            log(t("FATAL: An unhandled exception occurred"), log.error);
            log(err.stack, log.error);
            this.exit(false);
        });
    }
    
    init() {
        this.#mw.init();
    }
    
    async processCommand(interaction) {
		let command = this.#commands[interaction.commandName];

		if (!interaction.inGuild() /*&& command.opts.guildsOnly*/) {
			interaction.reply((await i18n(interaction)).t("You can't run this command here."));
			return;
		}

		if (!command.canRun(interaction)) {
			interaction.reply((await i18n(interaction)).t("You're now allowed to run this command."));
			return;
		}

		// Read arguments
		let actualArgs = {};
		if (command.args) {
			matchArguments(interaction, actualArgs, command.args);
		}
		
		// Run through middleware
		let actualOpts = {};
		if (!await this.#mw.run(interaction, actualOpts, command.opts, actualArgs));

		if (command.opts.translatorRequired) {
			actualOpts.t = (await i18n(interaction)).t;
		}

		if (command.opts.dbRequired) {
			actualOpts.db = await db.get();
		}

		await command.run(interaction, actualOpts, actualArgs);

		if (command.opts.dbRequired && !command.opts.noReleaseDb) {
			actualOpts.db.release();
		}
    }

    setBot(bot) {
        this.#bot = bot;
        
        for (let listener of this.#pendingListeners) {
            this.#bot.on(listener.name, listener.listener);
        }
        this.#pendingListeners = [];
        
        this.#bot.once("ready", () => this.emit("botAvailable"));
    }
    
    get bot() {
        return this.#bot;
    }
    
    register(name, args, func) {
		if (this.#commands[name]) {
			log(t("Command {{COMMAND}} was registered already! New registration ignored.", {"COMMAND": name}), log.warn);
			return;
		}
		this.#commands[name] = new SimpleHandlerCommand(args, func);
    }

	registerParent(name, args) {
		if (this.#commands[name]) {
			log(t("Command {{COMMAND}} was registered already! New registration ignored.", {"COMMAND": name}), log.warn);
			return;
		}
		let command = new HandlerCommandParent(args);
		this.#commands[name] = command;
		return command;
	}

	pushCommands() {
		log(t("Registering commands globally..."), log.info);
		commandRegistration.pushGlobally(this.#commands);

		const guilds = config.get("fastregisterguilds");
		if (guilds.length === 0) return;

		log(t("Registering commands for {{count}} guilds", {"count": guilds.length}), log.info);
		for (const guildid of guilds) {
			commandRegistration.pushGuild(this.#commands, guildid);
		}
	}
    
    listen(eventName, listener) {
        if (this.#bot) {
            this.#bot.on(eventName, listener);
        } else {
            this.#pendingListeners.push({
                name: eventName,
                listener: listener
            });
        }
    }
    
    stopListen(eventName, listener) {
        this.#bot.off(eventName, listener);
    }
    
    exit(clean = true) {
        if (clean) {
            log(t("Shutting down {{BOT_NAME}}..."), {"BOT_NAME": config.get("bot.name")});
            this.emit("quit");
            this.#bot.destroy();
            log(t("See you next time!"), log.success);
            process.exit(0);
        } else {
            //Kill the bot
            this.emit("quit");
            if (this.#bot) this.#bot.destroy();
            
            log(t("FATAL: An unrecoverable error occurred, so we'll need to exit now."), log.error);
            process.exit(1);
        }
    }
    
    get commands() {
        return this.#commands;
    }
}

let handler = new Handler();
module.exports = handler;
