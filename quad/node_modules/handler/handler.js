const Lexer = require('./lexer');
const HandlerCommandMatcher = require("./handlercommandmatcher");
const HandlerCommand = require("./handlercommand");
const config = require("config");
const i18n = require("i18n");
const MiddlewareLoader = require("../../middlewareloader");
const EventEmitter = require("events");
const log = require("log");

const commandRatelimit = config.get("bot.ratelimit.commands");
const t = i18n.t;

class Handler extends EventEmitter {
    #commands;
    #bot;
    #pendingListeners;
    #links;
    #mw;
    
    constructor() {
        super();
        
        this.#commands = [];
        this.#pendingListeners = [];
        this.#links = {};
        this.#mw = new MiddlewareLoader();
        

        process.on("uncaughtException", err => {
            log(t("FATAL: An unhandled exception occurred"), log.error);
            log(err.stack, log.error);
            this.exit(false);
        });
    }
    
    init() {
        this.#mw.init();
    }
    
    async process(prefix, message) {
        let l = new Lexer(message.content.substr(prefix.length));
        if (l.atEnd) return;
        
        try {
            let firstToken = l.lex();
            if (firstToken.type !== "string") {
                message.channel.createMessage("Syntax Error");
                return;
            }
            
            let commandName = firstToken.value;
            if (this.#links.hasOwnProperty(commandName)) {
                commandName = this.#links[commandName];
            }
            
            //Iterate over the commands and find the commands with this name
            let matchers = [];
            for (let command of this.#commands) {
                if (command.name === commandName) matchers.push(new HandlerCommandMatcher(command, message.channel.guild));
            }
            if (matchers.length === 0) return; //No such command exists
            
            //Now attempt to match the rest of the tokens with the command
            while (!l.atEnd) {
                let token = l.lex();
                for (let matcher of matchers) {
                    await matcher.token(token);
                }
            }
            
            //And run the first registered matching command that can run
            let commandRun = false;
            for (let matcher of matchers) {
                if (!matcher.canRunCommand()) continue;
                commandRun = true;
                
                //Ensure we have permissions
                if (!matcher.havePermission(message.member)) continue;
                
                matcher.runCommand(prefix, message, this.#mw);
                break;
            }
            
            //Check if any commands were run
            if (!commandRun) {
                //Invalid arguments; print an error
                message.channel.createMessage("Invalid Arguments");
            }
        } catch (err) {
            message.channel.createMessage(err.message);
            console.log(err);
        }
    }
    
    setBot(bot) {
        this.#bot = bot;
        
        for (let listener of this.#pendingListeners) {
            this.#bot.on(listener.name, listener.listener);
        }
        this.#pendingListeners = [];
        
        this.emit("botAvailable");
    }
    
    get bot() {
        return this.#bot;
    }
    
    readlink(source) {
        return this.#links[source];
    }
    
    register(name, args, func) {
        let command = new HandlerCommand(name, args, func);
        this.#commands.push(command);
    }
    
    link(source, dest) {
        this.#links[source] = dest;
    }
    
    listen(eventName, listener) {
        if (this.#bot) {
            this.#bot.on(eventName, listener);
        } else {
            this.#pendingListeners.push({
                name: eventName,
                listener: listener
            });
        }
    }
    
    stopListen(eventName, listener) {
        this.#bot.off(eventName, listener);
    }
    
    exit(clean = true) {
        if (clean) {
            log(t("Shutting down {{BOT_NAME}}..."), {"BOT_NAME": config.get("bot.name")});
            this.emit("quit");
            this.#bot.disconnect({reconnect: false});
            log(t("See you next time!"), log.success);
            process.exit(0);
        } else {
            //Kill the bot
            this.emit("quit");
            if (this.#bot) this.#bot.disconnect({reconnect: false});
            
            log(t("FATAL: An unrecoverable error occurred, so we'll need to exit now."), log.error);
            process.exit(1);
        }
    }
    
    get commands() {
        return this.#commands;
    }
}

let handler = new Handler();
module.exports = handler;