const fs = require("fs");
const events = require("events");
const readline = require("readline");
const db = require("db");

class Geo {
    static get canGeocode() {
        return fs.existsSync("./data/geonames.txt");
    }

    static async getPlaceName(location) {
        if (!this.canGeocode) throw new Error("Geonames database does not exist");
        if (location === null) return null;

        let closest = null;
        let reader = readline.createInterface({
            input: fs.createReadStream("./data/geonames.txt")
        });
        reader.on("line", line => {
            let bits = line.split("\t");
            let lat = parseFloat(bits[4]);
            let lon = parseFloat(bits[5]);

            let distance = Math.sqrt(
                Math.pow(location[0] - lat, 2) +
                Math.pow(location[1] - lon, 2)
            )

            if (closest !== null) {
                if (closest.distance < distance) return;
            }

            closest = {
                name: bits[1],
                country: bits[8],
                distance: distance,
                tz: bits[17]
            };
        });

        await events.once(reader, 'close');

        return closest;
    }

    static async getCoords(location) {
        if (!this.canGeocode) throw new Error("Geonames database does not exist");
        if (location === null) return null;

        //Select the city with the largest population
        let best = null;
        let reader = readline.createInterface({
            input: fs.createReadStream("./data/geonames.txt")
        });
        reader.on("line", line => {
            let bits = line.split("\t");
            let name = bits[1];
            let asciiname = bits[2];

            //Make sure this is the city we're looking for
            if (name.toLowerCase() != location.toLowerCase() && asciiname.toLowerCase() != location.toLowerCase()) return;

            let lat = parseFloat(bits[4]);
            let lon = parseFloat(bits[5]);
            let pop = parseInt(bits[14]);

            if (best !== null) {
                if (best.population > pop) return;
            }

            best = {
                name: bits[1],
                country: bits[8],
                population: pop,
                tz: bits[17],
                location: [lat, lon]
            };
        });

        await events.once(reader, 'close');

        return best;
    }

    static async getUser(id) {
        let row = await db.getPool().query("SELECT coords FROM usergeography WHERE id=$1", [id]);
        if (row.rowCount > 0) {
            return [row.rows[0].coords.x, row.rows[0].coords.y];
        } else {
            return null;
        }
    }

    static locationToString(location, t) {
        let lat = location[0];
        if (lat < 0) {
            lat = `${Math.abs(lat)}째 ${t("TRANSLATORS: Use one letter for the following translation: \"S\" for \"South\"")}`
        } else {
            lat = `${Math.abs(lat)}째 ${t("TRANSLATORS: Use one letter for the following translation: \"N\" for \"North\"")}`
        }

        let lon = location[1];
        if (lon < 0) {
            lon = `${Math.abs(lon)}째 ${t("TRANSLATORS: Use one letter for the following translation: \"W\" for \"West\"")}`
        } else {
            lon = `${Math.abs(lon)}째 ${t("TRANSLATORS: Use one letter for the following translation: \"E\" for \"East\"")}`
        }

        return `${lat}, ${lon}`;
    }
}

module.exports = Geo;
